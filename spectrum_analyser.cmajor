namespace spectrum_analyser
{
    let DFT_BUFFER_SIZE = 8192;
    let MEMORY_FRAMES = 5;

    struct Spectrum
    {
        float[DFT_BUFFER_SIZE/2] magnitudes;
        float[DFT_BUFFER_SIZE/2] peakMagnitudes;
    }


    graph Analyser  [[main]]
    {
        input  stream float<2> audioIn;
        output stream float<2> audioOut;
        output dft.spectrum;

        node dft = DFT;

        // audio routing
        connection
        {
            audioIn -> audioOut, dft.stereoWave;
        }
    }


    processor DFT
    {
        input stream float<2> stereoWave;
        output event Spectrum spectrum;

        let fftSize = DFT_BUFFER_SIZE / 2;
        let windowSize = DFT_BUFFER_SIZE / 4;
        let fftsPerSecond = 20;
        let framesBetweenFtts = (processor.frequency / fftsPerSecond) - windowSize;

        wrap<MEMORY_FRAMES> memoryIdx = 0;
        float[DFT_BUFFER_SIZE, MEMORY_FRAMES] magnitudeMemory;
        float[DFT_BUFFER_SIZE] waveBuffer;

        float[windowSize] hann()
        {
            float[windowSize] window;

            for (wrap<windowSize> i)
                window[i] = float (0.5 * (1.0 - cos(2.0 * pi * i / (windowSize - 1))));

            return window;
        }

        float[windowSize] window = hann();

        float normalizationFactor = 1.0f / windowSize;

        void main()
        {
            loop
            {
                ++memoryIdx;
                for (wrap<windowSize> counter)
                {
                    waveBuffer[counter] = (stereoWave[0] + stereoWave[1]) / 2.0f * window[counter];
                    advance();
                }

                // Calculate the spectrum
                float[DFT_BUFFER_SIZE] complexSpectrum;
                std::frequency::realOnlyForwardFFT(waveBuffer, complexSpectrum);

                Spectrum magSpectrum;
                for (wrap<fftSize> binIdx)
                {
                    float real = complexSpectrum[binIdx];
                    float imag = complexSpectrum.at(fftSize + binIdx);
                    magSpectrum.magnitudes[binIdx] = sqrt(real * real + imag * imag) * normalizationFactor * 1000.0f;
                    magnitudeMemory[binIdx, memoryIdx] = magSpectrum.magnitudes[binIdx];
                }

                // Calculate peak magnitude spectrum
                for (wrap<fftSize> binIdx)
                {
                    float peak = 0.0f;
                    for (wrap<MEMORY_FRAMES> memoryIdx)
                    {
                        if (magnitudeMemory[binIdx, memoryIdx] > peak)
                            peak = magnitudeMemory[binIdx, memoryIdx];
                    }
                    magSpectrum.peakMagnitudes[binIdx] = peak;
                }

                spectrum <- magSpectrum;

                // if const (framesBetweenFtts > 0)
                //     loop (framesBetweenFtts)
                //         advance();
            }
        }
    }
}
